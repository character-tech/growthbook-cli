/* tslint:disable */
/* eslint-disable */
/**
 * GrowthBook REST API
 * GrowthBook offers a full REST API for interacting with the GrowthBook application. This is currently in **beta** as we add more authenticated API routes and features.  Request data can use either JSON or Form data encoding (with proper `Content-Type` headers). All response bodies are JSON-encoded.  The API base URL for GrowthBook Cloud is `https://api.growthbook.io`. For self-hosted deployments, it is the same as your API_HOST environment variable (defaults to `http://localhost:3100`). The rest of these docs will assume you are using GrowthBook Cloud.  ## Authentication  We support both the HTTP Basic and Bearer authentication schemes for convenience.  You first need to generate a new API Key in GrowthBook. Different keys have different permissions:  - **Personal Access Tokens**: These are sensitive and provide the same level of access as the user has to an organization. These can be created by going to `Personal Access Tokens` under the your user menu. - **Secret Keys**: These are sensitive and provide the level of access for the role, which currently is either `admin` or `readonly`. Only Admins with the `manageApiKeys` permission can manage Secret Keys on behalf of an organization. These can be created by going to `Settings -> API Keys`  If using HTTP Basic auth, pass the Secret Key as the username and leave the password blank:  ```bash curl https://api.growthbook.io/api/v1 \\   -u secret_abc123DEF456: # The \":\" at the end stops curl from asking for a password ```  If using Bearer auth, pass the Secret Key as the token:  ```bash curl https://api.growthbook.io/api/v1 \\ -H \"Authorization: Bearer secret_abc123DEF456\" ```  ## Errors  The API may return the following error status codes:  - **400** - Bad Request - Often due to a missing required parameter - **401** - Unauthorized - No valid API key provided - **402** - Request Failed - The parameters are valid, but the request failed - **403** - Forbidden - Provided API key does not have the required access - **404** - Not Found - Unknown API route or requested resource - **429** - Too Many Requests - You exceeded the rate limit of 60 requests per minute. Try again later. - **5XX** - Server Error - Something went wrong on GrowthBook\'s end (these are rare)  The response body will be a JSON object with the following properties:  - **message** - Information about the error 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'projectIds': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'eventTracker': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'identifierTypes': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'assignmentQueries': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'identifierJoinQueries': any;
    /**
     * 
     * @type {DataSourceMixpanelSettings}
     * @memberof DataSource
     */
    'mixpanelSettings'?: DataSourceMixpanelSettings;
}
/**
 * 
 * @export
 * @interface DataSourceMixpanelSettings
 */
export interface DataSourceMixpanelSettings {
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'viewedExperimentEventName': any;
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'experimentIdProperty': any;
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'variationIdProperty': any;
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'extraUserIdProperty': any;
}
/**
 * 
 * @export
 * @interface DeleteMetric200Response
 */
export interface DeleteMetric200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteMetric200Response
     */
    'deletedId': string;
}
/**
 * 
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'dateUpdated': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'datasourceId': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'identifierType': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'project': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'hypothesis': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'tags': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'owner': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'archived': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'status': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'autoRefresh': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'hashAttribute': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'hashVersion': ExperimentHashVersionEnum;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'variations': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'phases': any;
    /**
     * 
     * @type {ExperimentAnalysisSettings}
     * @memberof Experiment
     */
    'settings': ExperimentAnalysisSettings;
    /**
     * 
     * @type {ExperimentResultSummary}
     * @memberof Experiment
     */
    'resultSummary'?: ExperimentResultSummary;
}

export const ExperimentHashVersionEnum = {
    _1: '1',
    _2: '2'
} as const;

export type ExperimentHashVersionEnum = typeof ExperimentHashVersionEnum[keyof typeof ExperimentHashVersionEnum];

/**
 * 
 * @export
 * @interface ExperimentAnalysisSettings
 */
export interface ExperimentAnalysisSettings {
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'datasourceId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'assignmentQueryId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'experimentId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'segmentId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'queryFilter': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'inProgressConversions': ExperimentAnalysisSettingsInProgressConversionsEnum;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'attributionModel': ExperimentAnalysisSettingsAttributionModelEnum;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'statsEngine': ExperimentAnalysisSettingsStatsEngineEnum;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'goals': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'guardrails': any;
    /**
     * 
     * @type {ExperimentMetric}
     * @memberof ExperimentAnalysisSettings
     */
    'activationMetric'?: ExperimentMetric;
}

export const ExperimentAnalysisSettingsInProgressConversionsEnum = {
    Include: 'include',
    Exclude: 'exclude'
} as const;

export type ExperimentAnalysisSettingsInProgressConversionsEnum = typeof ExperimentAnalysisSettingsInProgressConversionsEnum[keyof typeof ExperimentAnalysisSettingsInProgressConversionsEnum];
export const ExperimentAnalysisSettingsAttributionModelEnum = {
    FirstExposure: 'firstExposure',
    ExperimentDuration: 'experimentDuration'
} as const;

export type ExperimentAnalysisSettingsAttributionModelEnum = typeof ExperimentAnalysisSettingsAttributionModelEnum[keyof typeof ExperimentAnalysisSettingsAttributionModelEnum];
export const ExperimentAnalysisSettingsStatsEngineEnum = {
    Bayesian: 'bayesian',
    Frequentist: 'frequentist'
} as const;

export type ExperimentAnalysisSettingsStatsEngineEnum = typeof ExperimentAnalysisSettingsStatsEngineEnum[keyof typeof ExperimentAnalysisSettingsStatsEngineEnum];

/**
 * 
 * @export
 * @interface ExperimentMetric
 */
export interface ExperimentMetric {
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetric
     */
    'metricId': any;
    /**
     * 
     * @type {ExperimentMetricOverrides}
     * @memberof ExperimentMetric
     */
    'overrides': ExperimentMetricOverrides;
}
/**
 * 
 * @export
 * @interface ExperimentMetricOverrides
 */
export interface ExperimentMetricOverrides {
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'conversionWindowStart'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'conversionWindowEnd'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'winRiskThreshold'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'loseRiskThreshold'?: any;
}
/**
 * 
 * @export
 * @interface ExperimentResultSummary
 */
export interface ExperimentResultSummary {
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'status': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'winner': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'conclusions': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'releasedVariationId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'excludeFromPayload': any;
}
/**
 * 
 * @export
 * @interface ExperimentResults
 */
export interface ExperimentResults {
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'experimentId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'phase': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'dateStart': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'dateEnd': any;
    /**
     * 
     * @type {ExperimentResultsDimension}
     * @memberof ExperimentResults
     */
    'dimension': ExperimentResultsDimension;
    /**
     * 
     * @type {ExperimentAnalysisSettings}
     * @memberof ExperimentResults
     */
    'settings': ExperimentAnalysisSettings;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'queryIds': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'results': any;
}
/**
 * 
 * @export
 * @interface ExperimentResultsDimension
 */
export interface ExperimentResultsDimension {
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultsDimension
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultsDimension
     */
    'id'?: any;
}
/**
 * 
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'dateUpdated': string;
    /**
     * 
     * @type {boolean}
     * @memberof Feature
     */
    'archived': boolean;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'valueType': FeatureValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'defaultValue': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Feature
     */
    'tags': Array<string>;
    /**
     * 
     * @type {{ [key: string]: FeatureEnvironment; }}
     * @memberof Feature
     */
    'environments': { [key: string]: FeatureEnvironment; };
    /**
     * 
     * @type {FeatureRevision}
     * @memberof Feature
     */
    'revision': FeatureRevision;
}

export const FeatureValueTypeEnum = {
    Boolean: 'boolean',
    String: 'string',
    Number: 'number',
    Json: 'json'
} as const;

export type FeatureValueTypeEnum = typeof FeatureValueTypeEnum[keyof typeof FeatureValueTypeEnum];

/**
 * 
 * @export
 * @interface FeatureDefinition
 */
export interface FeatureDefinition {
    /**
     * 
     * @type {FeatureDefinitionDefaultValue}
     * @memberof FeatureDefinition
     */
    'defaultValue': FeatureDefinitionDefaultValue | null;
    /**
     * 
     * @type {any}
     * @memberof FeatureDefinition
     */
    'rules'?: any;
}
/**
 * 
 * @export
 * @interface FeatureDefinitionDefaultValue
 */
export interface FeatureDefinitionDefaultValue {
}
/**
 * 
 * @export
 * @interface FeatureEnvironment
 */
export interface FeatureEnvironment {
    /**
     * 
     * @type {boolean}
     * @memberof FeatureEnvironment
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof FeatureEnvironment
     */
    'defaultValue': string;
    /**
     * 
     * @type {Array<FeatureRule>}
     * @memberof FeatureEnvironment
     */
    'rules': Array<FeatureRule>;
    /**
     * A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)
     * @type {string}
     * @memberof FeatureEnvironment
     */
    'definition'?: string;
    /**
     * 
     * @type {FeatureEnvironmentDraft}
     * @memberof FeatureEnvironment
     */
    'draft'?: FeatureEnvironmentDraft;
}
/**
 * 
 * @export
 * @interface FeatureEnvironmentDraft
 */
export interface FeatureEnvironmentDraft {
    /**
     * 
     * @type {boolean}
     * @memberof FeatureEnvironmentDraft
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof FeatureEnvironmentDraft
     */
    'defaultValue': string;
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironmentDraft
     */
    'rules': any;
    /**
     * A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)
     * @type {string}
     * @memberof FeatureEnvironmentDraft
     */
    'definition'?: string;
}
/**
 * 
 * @export
 * @interface FeatureExperimentRefRule
 */
export interface FeatureExperimentRefRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'condition'?: any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'variations': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRefRule
     */
    'experimentId': any;
}
/**
 * 
 * @export
 * @interface FeatureExperimentRule
 */
export interface FeatureExperimentRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'trackingKey'?: any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'hashAttribute'?: any;
    /**
     * 
     * @type {FeatureExperimentRuleNamespace}
     * @memberof FeatureExperimentRule
     */
    'namespace'?: FeatureExperimentRuleNamespace;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'coverage'?: any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface FeatureExperimentRuleNamespace
 */
export interface FeatureExperimentRuleNamespace {
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRuleNamespace
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRuleNamespace
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRuleNamespace
     */
    'range': any;
}
/**
 * 
 * @export
 * @interface FeatureForceRule
 */
export interface FeatureForceRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface FeatureRevision
 */
export interface FeatureRevision {
    /**
     * 
     * @type {number}
     * @memberof FeatureRevision
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof FeatureRevision
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureRevision
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureRevision
     */
    'publishedBy': string;
}
/**
 * 
 * @export
 * @interface FeatureRolloutRule
 */
export interface FeatureRolloutRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'value': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'coverage': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'hashAttribute': any;
}
/**
 * 
 * @export
 * @interface FeatureRule
 */
export interface FeatureRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'value': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'coverage': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'hashAttribute': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'trackingKey'?: any;
    /**
     * 
     * @type {FeatureExperimentRuleNamespace}
     * @memberof FeatureRule
     */
    'namespace'?: FeatureExperimentRuleNamespace;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'variations': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRule
     */
    'experimentId': any;
}
/**
 * 
 * @export
 * @interface GetDataSource200Response
 */
export interface GetDataSource200Response {
    /**
     * 
     * @type {DataSource}
     * @memberof GetDataSource200Response
     */
    'dataSource': DataSource;
}
/**
 * 
 * @export
 * @interface GetDimension200Response
 */
export interface GetDimension200Response {
    /**
     * 
     * @type {Dimension}
     * @memberof GetDimension200Response
     */
    'dimension': Dimension;
}
/**
 * 
 * @export
 * @interface GetExperimentResults200Response
 */
export interface GetExperimentResults200Response {
    /**
     * 
     * @type {ExperimentResults}
     * @memberof GetExperimentResults200Response
     */
    'result'?: ExperimentResults;
}
/**
 * 
 * @export
 * @interface GetProject200Response
 */
export interface GetProject200Response {
    /**
     * 
     * @type {Project}
     * @memberof GetProject200Response
     */
    'project': Project;
}
/**
 * 
 * @export
 * @interface GetSdkConnection200Response
 */
export interface GetSdkConnection200Response {
    /**
     * 
     * @type {SdkConnection}
     * @memberof GetSdkConnection200Response
     */
    'sdkConnection': SdkConnection;
}
/**
 * 
 * @export
 * @interface GetSegment200Response
 */
export interface GetSegment200Response {
    /**
     * 
     * @type {Segment}
     * @memberof GetSegment200Response
     */
    'segment': Segment;
}
/**
 * 
 * @export
 * @interface GetVisualChangeset200Response
 */
export interface GetVisualChangeset200Response {
    /**
     * 
     * @type {VisualChangeset}
     * @memberof GetVisualChangeset200Response
     */
    'visualChangeset': VisualChangeset;
    /**
     * 
     * @type {Experiment}
     * @memberof GetVisualChangeset200Response
     */
    'experiment'?: Experiment;
}
/**
 * 
 * @export
 * @interface ListDataSources200Response
 */
export interface ListDataSources200Response {
    /**
     * 
     * @type {number}
     * @memberof ListDataSources200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListDataSources200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListDataSources200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListDataSources200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListDataSources200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListDataSources200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<DataSource>}
     * @memberof ListDataSources200Response
     */
    'dataSources': Array<DataSource>;
}
/**
 * 
 * @export
 * @interface ListDimensions200Response
 */
export interface ListDimensions200Response {
    /**
     * 
     * @type {number}
     * @memberof ListDimensions200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListDimensions200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListDimensions200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListDimensions200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListDimensions200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListDimensions200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Dimension>}
     * @memberof ListDimensions200Response
     */
    'dimensions': Array<Dimension>;
}
/**
 * 
 * @export
 * @interface ListExperiments200Response
 */
export interface ListExperiments200Response {
    /**
     * 
     * @type {number}
     * @memberof ListExperiments200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListExperiments200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListExperiments200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListExperiments200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListExperiments200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListExperiments200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Experiment>}
     * @memberof ListExperiments200Response
     */
    'experiments': Array<Experiment>;
}
/**
 * 
 * @export
 * @interface ListFeatures200Response
 */
export interface ListFeatures200Response {
    /**
     * 
     * @type {number}
     * @memberof ListFeatures200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListFeatures200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListFeatures200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListFeatures200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListFeatures200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListFeatures200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Feature>}
     * @memberof ListFeatures200Response
     */
    'features': Array<Feature>;
}
/**
 * 
 * @export
 * @interface ListMetrics200Response
 */
export interface ListMetrics200Response {
    /**
     * 
     * @type {number}
     * @memberof ListMetrics200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListMetrics200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListMetrics200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListMetrics200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListMetrics200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListMetrics200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Metric>}
     * @memberof ListMetrics200Response
     */
    'metrics': Array<Metric>;
}
/**
 * 
 * @export
 * @interface ListOrganizations200Response
 */
export interface ListOrganizations200Response {
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListOrganizations200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof ListOrganizations200Response
     */
    'organizations': Array<Organization>;
}
/**
 * 
 * @export
 * @interface ListProjects200Response
 */
export interface ListProjects200Response {
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListProjects200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Project>}
     * @memberof ListProjects200Response
     */
    'projects': Array<Project>;
}
/**
 * 
 * @export
 * @interface ListSavedGroups200Response
 */
export interface ListSavedGroups200Response {
    /**
     * 
     * @type {number}
     * @memberof ListSavedGroups200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListSavedGroups200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListSavedGroups200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListSavedGroups200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListSavedGroups200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListSavedGroups200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<SavedGroup>}
     * @memberof ListSavedGroups200Response
     */
    'savedGroups': Array<SavedGroup>;
}
/**
 * 
 * @export
 * @interface ListSdkConnections200Response
 */
export interface ListSdkConnections200Response {
    /**
     * 
     * @type {number}
     * @memberof ListSdkConnections200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListSdkConnections200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListSdkConnections200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListSdkConnections200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListSdkConnections200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListSdkConnections200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<SdkConnection>}
     * @memberof ListSdkConnections200Response
     */
    'connections'?: Array<SdkConnection>;
}
/**
 * 
 * @export
 * @interface ListSegments200Response
 */
export interface ListSegments200Response {
    /**
     * 
     * @type {number}
     * @memberof ListSegments200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListSegments200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ListSegments200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ListSegments200Response
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof ListSegments200Response
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListSegments200Response
     */
    'nextOffset': number | null;
    /**
     * 
     * @type {Array<Segment>}
     * @memberof ListSegments200Response
     */
    'segments': Array<Segment>;
}
/**
 * 
 * @export
 * @interface ListVisualChangesets200Response
 */
export interface ListVisualChangesets200Response {
    /**
     * 
     * @type {Array<VisualChangeset>}
     * @memberof ListVisualChangesets200Response
     */
    'visualChangesets': Array<VisualChangeset>;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'dateUpdated': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'datasourceId': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'type': MetricTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Metric
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Metric
     */
    'projects': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Metric
     */
    'archived': boolean;
    /**
     * 
     * @type {MetricBehavior}
     * @memberof Metric
     */
    'behavior': MetricBehavior;
    /**
     * 
     * @type {MetricSql}
     * @memberof Metric
     */
    'sql'?: MetricSql;
    /**
     * 
     * @type {MetricSqlBuilder}
     * @memberof Metric
     */
    'sqlBuilder'?: MetricSqlBuilder;
    /**
     * 
     * @type {MetricMixpanel}
     * @memberof Metric
     */
    'mixpanel'?: MetricMixpanel;
}

export const MetricTypeEnum = {
    Binomial: 'binomial',
    Count: 'count',
    Duration: 'duration',
    Revenue: 'revenue'
} as const;

export type MetricTypeEnum = typeof MetricTypeEnum[keyof typeof MetricTypeEnum];

/**
 * 
 * @export
 * @interface MetricBehavior
 */
export interface MetricBehavior {
    /**
     * 
     * @type {string}
     * @memberof MetricBehavior
     */
    'goal': MetricBehaviorGoalEnum;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'cap'?: number;
    /**
     * 
     * @type {string}
     * @memberof MetricBehavior
     */
    'capping'?: MetricBehaviorCappingEnum;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'capValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'conversionWindowStart': number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'conversionWindowEnd': number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'riskThresholdSuccess': number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'riskThresholdDanger': number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'minPercentChange': number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'maxPercentChange': number;
    /**
     * 
     * @type {number}
     * @memberof MetricBehavior
     */
    'minSampleSize': number;
}

export const MetricBehaviorGoalEnum = {
    Increase: 'increase',
    Decrease: 'decrease'
} as const;

export type MetricBehaviorGoalEnum = typeof MetricBehaviorGoalEnum[keyof typeof MetricBehaviorGoalEnum];
export const MetricBehaviorCappingEnum = {
    Absolute: 'absolute',
    Percentile: 'percentile'
} as const;

export type MetricBehaviorCappingEnum = typeof MetricBehaviorCappingEnum[keyof typeof MetricBehaviorCappingEnum];

/**
 * 
 * @export
 * @interface MetricMixpanel
 */
export interface MetricMixpanel {
    /**
     * 
     * @type {string}
     * @memberof MetricMixpanel
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricMixpanel
     */
    'eventValue': string;
    /**
     * 
     * @type {string}
     * @memberof MetricMixpanel
     */
    'userAggregation': string;
    /**
     * 
     * @type {Array<PostMetricRequestMixpanelConditionsInner>}
     * @memberof MetricMixpanel
     */
    'conditions': Array<PostMetricRequestMixpanelConditionsInner>;
}
/**
 * 
 * @export
 * @interface MetricSql
 */
export interface MetricSql {
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricSql
     */
    'identifierTypes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MetricSql
     */
    'conversionSQL': string;
    /**
     * 
     * @type {string}
     * @memberof MetricSql
     */
    'userAggregationSQL': string;
    /**
     * 
     * @type {string}
     * @memberof MetricSql
     */
    'denominatorMetricId': string;
}
/**
 * 
 * @export
 * @interface MetricSqlBuilder
 */
export interface MetricSqlBuilder {
    /**
     * 
     * @type {Array<PostMetricRequestSqlBuilderIdentifierTypeColumnsInner>}
     * @memberof MetricSqlBuilder
     */
    'identifierTypeColumns': Array<PostMetricRequestSqlBuilderIdentifierTypeColumnsInner>;
    /**
     * 
     * @type {string}
     * @memberof MetricSqlBuilder
     */
    'tableName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricSqlBuilder
     */
    'valueColumnName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricSqlBuilder
     */
    'timestampColumnName': string;
    /**
     * 
     * @type {Array<PostMetricRequestSqlBuilderConditionsInner>}
     * @memberof MetricSqlBuilder
     */
    'conditions': Array<PostMetricRequestSqlBuilderConditionsInner>;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * The unique identifier for the organization
     * @type {any}
     * @memberof Organization
     */
    'id'?: any;
    /**
     * The date the organization was created
     * @type {any}
     * @memberof Organization
     */
    'dateCreated'?: any;
    /**
     * The name of the organization
     * @type {any}
     * @memberof Organization
     */
    'name'?: any;
    /**
     * The email address of the organization owner
     * @type {any}
     * @memberof Organization
     */
    'ownerEmail'?: any;
}
/**
 * 
 * @export
 * @interface PaginationFields
 */
export interface PaginationFields {
    /**
     * 
     * @type {number}
     * @memberof PaginationFields
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationFields
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationFields
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationFields
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginationFields
     */
    'hasMore': boolean;
    /**
     * 
     * @type {number}
     * @memberof PaginationFields
     */
    'nextOffset': number | null;
}
/**
 * 
 * @export
 * @interface PostExperiment200Response
 */
export interface PostExperiment200Response {
    /**
     * 
     * @type {Experiment}
     * @memberof PostExperiment200Response
     */
    'experiment': Experiment;
}
/**
 * 
 * @export
 * @interface PostExperimentRequest
 */
export interface PostExperimentRequest {
    /**
     * ID for the [DataSource](#tag/DataSource_model)
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'datasourceId': string;
    /**
     * The ID property of one of the assignment query objects associated with the datasource
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'assignmentQueryId': string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'trackingKey': string;
    /**
     * Name of the experiment
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'name': string;
    /**
     * Project ID which the experiment belongs to
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'project'?: string;
    /**
     * Hypothesis of the experiment
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'hypothesis'?: string;
    /**
     * Description of the experiment
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostExperimentRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostExperimentRequest
     */
    'metrics'?: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof PostExperimentRequest
     */
    'guardrailMetrics'?: any;
    /**
     * Email of the person who owns this experiment
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostExperimentRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'status'?: PostExperimentRequestStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PostExperimentRequest
     */
    'autoRefresh'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'hashAttribute'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostExperimentRequest
     */
    'hashVersion'?: PostExperimentRequestHashVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequest
     */
    'releasedVariationId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostExperimentRequest
     */
    'excludeFromPayload'?: boolean;
    /**
     * 
     * @type {Array<PostExperimentRequestVariationsInner>}
     * @memberof PostExperimentRequest
     */
    'variations': Array<PostExperimentRequestVariationsInner>;
    /**
     * 
     * @type {Array<PostExperimentRequestPhasesInner>}
     * @memberof PostExperimentRequest
     */
    'phases'?: Array<PostExperimentRequestPhasesInner>;
}

export const PostExperimentRequestStatusEnum = {
    Draft: 'draft',
    Running: 'running',
    Stopped: 'stopped'
} as const;

export type PostExperimentRequestStatusEnum = typeof PostExperimentRequestStatusEnum[keyof typeof PostExperimentRequestStatusEnum];
export const PostExperimentRequestHashVersionEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostExperimentRequestHashVersionEnum = typeof PostExperimentRequestHashVersionEnum[keyof typeof PostExperimentRequestHashVersionEnum];

/**
 * 
 * @export
 * @interface PostExperimentRequestPhasesInner
 */
export interface PostExperimentRequestPhasesInner {
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'dateStarted': string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'dateEnded'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'reasonForStopping'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'seed'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostExperimentRequestPhasesInner
     */
    'coverage'?: number;
    /**
     * 
     * @type {Array<PostExperimentRequestPhasesInnerTrafficSplitInner>}
     * @memberof PostExperimentRequestPhasesInner
     */
    'trafficSplit'?: Array<PostExperimentRequestPhasesInnerTrafficSplitInner>;
    /**
     * 
     * @type {PostExperimentRequestPhasesInnerNamespace}
     * @memberof PostExperimentRequestPhasesInner
     */
    'namespace'?: PostExperimentRequestPhasesInnerNamespace;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'targetingCondition'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInner
     */
    'condition'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PostExperimentRequestPhasesInner
     */
    'variationWeights'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PostExperimentRequestPhasesInnerNamespace
 */
export interface PostExperimentRequestPhasesInnerNamespace {
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInnerNamespace
     */
    'namespaceId': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PostExperimentRequestPhasesInnerNamespace
     */
    'range': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof PostExperimentRequestPhasesInnerNamespace
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface PostExperimentRequestPhasesInnerTrafficSplitInner
 */
export interface PostExperimentRequestPhasesInnerTrafficSplitInner {
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestPhasesInnerTrafficSplitInner
     */
    'variationId': string;
    /**
     * 
     * @type {number}
     * @memberof PostExperimentRequestPhasesInnerTrafficSplitInner
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface PostExperimentRequestVariationsInner
 */
export interface PostExperimentRequestVariationsInner {
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestVariationsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestVariationsInner
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestVariationsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestVariationsInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<PostExperimentRequestVariationsInnerScreenshotsInner>}
     * @memberof PostExperimentRequestVariationsInner
     */
    'screenshots'?: Array<PostExperimentRequestVariationsInnerScreenshotsInner>;
}
/**
 * 
 * @export
 * @interface PostExperimentRequestVariationsInnerScreenshotsInner
 */
export interface PostExperimentRequestVariationsInnerScreenshotsInner {
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestVariationsInnerScreenshotsInner
     */
    'path': string;
    /**
     * 
     * @type {number}
     * @memberof PostExperimentRequestVariationsInnerScreenshotsInner
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof PostExperimentRequestVariationsInnerScreenshotsInner
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostExperimentRequestVariationsInnerScreenshotsInner
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PostFeature200Response
 */
export interface PostFeature200Response {
    /**
     * 
     * @type {Feature}
     * @memberof PostFeature200Response
     */
    'feature': Feature;
}
/**
 * 
 * @export
 * @interface PostFeatureRequest
 */
export interface PostFeatureRequest {
    /**
     * A unique key name for the feature. Feature keys can only include letters, numbers, hyphens, and underscores.
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostFeatureRequest
     */
    'archived'?: boolean;
    /**
     * Description of the feature
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'description'?: string;
    /**
     * Email of the person who owns this experiment
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'owner': string;
    /**
     * An associated project ID
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'project'?: string;
    /**
     * The data type of the feature payload. Boolean by default.
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'valueType': PostFeatureRequestValueTypeEnum;
    /**
     * Default value when feature is enabled. Type must match `valueType`.
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'defaultValue': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostFeatureRequest
     */
    'tags'?: Array<string>;
    /**
     * A dictionary of environments that are enabled for this feature. Keys supply the names of environments. Environments belong to organization and are not specified will be disabled by default.
     * @type {{ [key: string]: PostFeatureRequestEnvironmentsValue; }}
     * @memberof PostFeatureRequest
     */
    'environments'?: { [key: string]: PostFeatureRequestEnvironmentsValue; };
    /**
     * Use JSON schema to validate the payload of a JSON-type feature value (enterprise only).
     * @type {string}
     * @memberof PostFeatureRequest
     */
    'jsonSchema'?: string;
}

export const PostFeatureRequestValueTypeEnum = {
    Boolean: 'boolean',
    String: 'string',
    Number: 'number',
    Json: 'json'
} as const;

export type PostFeatureRequestValueTypeEnum = typeof PostFeatureRequestValueTypeEnum[keyof typeof PostFeatureRequestValueTypeEnum];

/**
 * 
 * @export
 * @interface PostFeatureRequestEnvironmentsValue
 */
export interface PostFeatureRequestEnvironmentsValue {
    /**
     * 
     * @type {boolean}
     * @memberof PostFeatureRequestEnvironmentsValue
     */
    'enabled': boolean;
    /**
     * 
     * @type {any}
     * @memberof PostFeatureRequestEnvironmentsValue
     */
    'rules'?: any;
    /**
     * A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)
     * @type {string}
     * @memberof PostFeatureRequestEnvironmentsValue
     */
    'definition'?: string;
    /**
     * 
     * @type {PostFeatureRequestEnvironmentsValueDraft}
     * @memberof PostFeatureRequestEnvironmentsValue
     */
    'draft'?: PostFeatureRequestEnvironmentsValueDraft;
}
/**
 * Use to write draft changes without publishing them.
 * @export
 * @interface PostFeatureRequestEnvironmentsValueDraft
 */
export interface PostFeatureRequestEnvironmentsValueDraft {
    /**
     * 
     * @type {boolean}
     * @memberof PostFeatureRequestEnvironmentsValueDraft
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof PostFeatureRequestEnvironmentsValueDraft
     */
    'rules'?: any;
    /**
     * A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)
     * @type {string}
     * @memberof PostFeatureRequestEnvironmentsValueDraft
     */
    'definition'?: string;
}
/**
 * 
 * @export
 * @interface PostMetric200Response
 */
export interface PostMetric200Response {
    /**
     * 
     * @type {Metric}
     * @memberof PostMetric200Response
     */
    'metric': Metric;
}
/**
 * 
 * @export
 * @interface PostMetricRequest
 */
export interface PostMetricRequest {
    /**
     * ID for the [DataSource](#tag/DataSource_model)
     * @type {string}
     * @memberof PostMetricRequest
     */
    'datasourceId': string;
    /**
     * Name of the person who owns this metric
     * @type {string}
     * @memberof PostMetricRequest
     */
    'owner'?: string;
    /**
     * Name of the metric
     * @type {string}
     * @memberof PostMetricRequest
     */
    'name': string;
    /**
     * Description of the metric
     * @type {string}
     * @memberof PostMetricRequest
     */
    'description'?: string;
    /**
     * Type of metric. See [Metrics documentation](/app/metrics)
     * @type {string}
     * @memberof PostMetricRequest
     */
    'type': PostMetricRequestTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostMetricRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostMetricRequest
     */
    'projects'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PostMetricRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {PostMetricRequestBehavior}
     * @memberof PostMetricRequest
     */
    'behavior'?: PostMetricRequestBehavior;
    /**
     * 
     * @type {PostMetricRequestSql}
     * @memberof PostMetricRequest
     */
    'sql'?: PostMetricRequestSql;
    /**
     * 
     * @type {PostMetricRequestSqlBuilder}
     * @memberof PostMetricRequest
     */
    'sqlBuilder'?: PostMetricRequestSqlBuilder;
    /**
     * 
     * @type {PostMetricRequestMixpanel}
     * @memberof PostMetricRequest
     */
    'mixpanel'?: PostMetricRequestMixpanel;
}

export const PostMetricRequestTypeEnum = {
    Binomial: 'binomial',
    Count: 'count',
    Duration: 'duration',
    Revenue: 'revenue'
} as const;

export type PostMetricRequestTypeEnum = typeof PostMetricRequestTypeEnum[keyof typeof PostMetricRequestTypeEnum];

/**
 * 
 * @export
 * @interface PostMetricRequestBehavior
 */
export interface PostMetricRequestBehavior {
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestBehavior
     */
    'goal'?: PostMetricRequestBehaviorGoalEnum;
    /**
     * (deprecated, use capping and capValue fields instead) This should be non-negative
     * @type {number}
     * @memberof PostMetricRequestBehavior
     * @deprecated
     */
    'cap'?: number;
    /**
     * Used in conjunction with `capValue` to set the capping (winsorization). Do not specify or set to null for no capping. \"absolute\" will cap user values at the `capValue` if it is greater than 0. \"percentile\" will cap user values at the percentile of user values in an experiment using the `capValue` for the percentile, if greater than 0. <br/>  If `behavior.capping` is non-null, you must specify `behavior.capValue`.
     * @type {string}
     * @memberof PostMetricRequestBehavior
     */
    'capping'?: PostMetricRequestBehaviorCappingEnum;
    /**
     * This should be non-negative. <br/> Must specify `behavior.capping` when setting `behavior.capValue`.
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'capValue'?: number;
    /**
     * The start of a Conversion Window relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics#conversion-delay). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'conversionWindowStart'?: number;
    /**
     * The end of a [Conversion Window](/app/metrics#conversion-window) relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics#conversion-delay) + Conversion Window Hours settings in the UI. In other words, if you want a 48 hour window starting after 24 hours, you would set conversionWindowStart to 24 and conversionWindowEnd to 72 (24+48). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'conversionWindowEnd'?: number;
    /**
     * Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'riskThresholdSuccess'?: number;
    /**
     * Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'riskThresholdDanger'?: number;
    /**
     * Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'minPercentChange'?: number;
    /**
     * Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'maxPercentChange'?: number;
    /**
     * 
     * @type {number}
     * @memberof PostMetricRequestBehavior
     */
    'minSampleSize'?: number;
}

export const PostMetricRequestBehaviorGoalEnum = {
    Increase: 'increase',
    Decrease: 'decrease'
} as const;

export type PostMetricRequestBehaviorGoalEnum = typeof PostMetricRequestBehaviorGoalEnum[keyof typeof PostMetricRequestBehaviorGoalEnum];
export const PostMetricRequestBehaviorCappingEnum = {
    Absolute: 'absolute',
    Percentile: 'percentile'
} as const;

export type PostMetricRequestBehaviorCappingEnum = typeof PostMetricRequestBehaviorCappingEnum[keyof typeof PostMetricRequestBehaviorCappingEnum];

/**
 * Only use for MixPanel (non-SQL) Data Sources. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.
 * @export
 * @interface PostMetricRequestMixpanel
 */
export interface PostMetricRequestMixpanel {
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestMixpanel
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestMixpanel
     */
    'eventValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestMixpanel
     */
    'userAggregation': string;
    /**
     * 
     * @type {Array<PostMetricRequestMixpanelConditionsInner>}
     * @memberof PostMetricRequestMixpanel
     */
    'conditions'?: Array<PostMetricRequestMixpanelConditionsInner>;
}
/**
 * 
 * @export
 * @interface PostMetricRequestMixpanelConditionsInner
 */
export interface PostMetricRequestMixpanelConditionsInner {
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestMixpanelConditionsInner
     */
    'property': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestMixpanelConditionsInner
     */
    'operator': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestMixpanelConditionsInner
     */
    'value': string;
}
/**
 * Preferred way to define SQL. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.
 * @export
 * @interface PostMetricRequestSql
 */
export interface PostMetricRequestSql {
    /**
     * 
     * @type {Array<string>}
     * @memberof PostMetricRequestSql
     */
    'identifierTypes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSql
     */
    'conversionSQL': string;
    /**
     * Custom user level aggregation for your metric (default: `SUM(value)`)
     * @type {string}
     * @memberof PostMetricRequestSql
     */
    'userAggregationSQL'?: string;
    /**
     * The metric ID for a [denominator metric for funnel and ratio metrics](/app/metrics#denominator-ratio--funnel-metrics)
     * @type {string}
     * @memberof PostMetricRequestSql
     */
    'denominatorMetricId'?: string;
}
/**
 * An alternative way to specify a SQL metric, rather than a full query. Using `sql` is preferred to `sqlBuilder`. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.
 * @export
 * @interface PostMetricRequestSqlBuilder
 */
export interface PostMetricRequestSqlBuilder {
    /**
     * 
     * @type {Array<PostMetricRequestSqlBuilderIdentifierTypeColumnsInner>}
     * @memberof PostMetricRequestSqlBuilder
     */
    'identifierTypeColumns': Array<PostMetricRequestSqlBuilderIdentifierTypeColumnsInner>;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilder
     */
    'tableName': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilder
     */
    'valueColumnName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilder
     */
    'timestampColumnName': string;
    /**
     * 
     * @type {Array<PostMetricRequestSqlBuilderConditionsInner>}
     * @memberof PostMetricRequestSqlBuilder
     */
    'conditions'?: Array<PostMetricRequestSqlBuilderConditionsInner>;
}
/**
 * 
 * @export
 * @interface PostMetricRequestSqlBuilderConditionsInner
 */
export interface PostMetricRequestSqlBuilderConditionsInner {
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilderConditionsInner
     */
    'column': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilderConditionsInner
     */
    'operator': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilderConditionsInner
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface PostMetricRequestSqlBuilderIdentifierTypeColumnsInner
 */
export interface PostMetricRequestSqlBuilderIdentifierTypeColumnsInner {
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilderIdentifierTypeColumnsInner
     */
    'identifierType': string;
    /**
     * 
     * @type {string}
     * @memberof PostMetricRequestSqlBuilderIdentifierTypeColumnsInner
     */
    'columnName': string;
}
/**
 * 
 * @export
 * @interface PostOrganization200Response
 */
export interface PostOrganization200Response {
    /**
     * 
     * @type {Organization}
     * @memberof PostOrganization200Response
     */
    'organization': Organization;
}
/**
 * 
 * @export
 * @interface PostOrganizationRequest
 */
export interface PostOrganizationRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof PostOrganizationRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PostSavedGroup200Response
 */
export interface PostSavedGroup200Response {
    /**
     * 
     * @type {SavedGroup}
     * @memberof PostSavedGroup200Response
     */
    'savedGroup': SavedGroup;
}
/**
 * 
 * @export
 * @interface PostSavedGroupRequest
 */
export interface PostSavedGroupRequest {
    /**
     * The display name of the Saved Group
     * @type {string}
     * @memberof PostSavedGroupRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostSavedGroupRequest
     */
    'values': Array<string>;
    /**
     * The parameter you want to target users with. Ex: userId, orgId, ...
     * @type {string}
     * @memberof PostSavedGroupRequest
     */
    'attributeKey': string;
    /**
     * The person or team that owns this Saved Group. If no owner, you can pass an empty string.
     * @type {string}
     * @memberof PostSavedGroupRequest
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface PostVisualChange200Response
 */
export interface PostVisualChange200Response {
    /**
     * 
     * @type {number}
     * @memberof PostVisualChange200Response
     */
    'nModified': number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'dateUpdated': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {ProjectSettings}
     * @memberof Project
     */
    'settings'?: ProjectSettings;
}
/**
 * 
 * @export
 * @interface ProjectSettings
 */
export interface ProjectSettings {
    /**
     * 
     * @type {string}
     * @memberof ProjectSettings
     */
    'statsEngine'?: string;
}
/**
 * 
 * @export
 * @interface PutMetric200Response
 */
export interface PutMetric200Response {
    /**
     * 
     * @type {string}
     * @memberof PutMetric200Response
     */
    'updatedId': string;
}
/**
 * 
 * @export
 * @interface PutMetricRequest
 */
export interface PutMetricRequest {
    /**
     * Name of the person who owns this metric
     * @type {string}
     * @memberof PutMetricRequest
     */
    'owner'?: string;
    /**
     * Name of the metric
     * @type {string}
     * @memberof PutMetricRequest
     */
    'name'?: string;
    /**
     * Description of the metric
     * @type {string}
     * @memberof PutMetricRequest
     */
    'description'?: string;
    /**
     * Type of metric. See [Metrics documentation](/app/metrics)
     * @type {string}
     * @memberof PutMetricRequest
     */
    'type'?: PutMetricRequestTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutMetricRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutMetricRequest
     */
    'projects'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PutMetricRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {PutMetricRequestBehavior}
     * @memberof PutMetricRequest
     */
    'behavior'?: PutMetricRequestBehavior;
    /**
     * 
     * @type {PutMetricRequestSql}
     * @memberof PutMetricRequest
     */
    'sql'?: PutMetricRequestSql;
    /**
     * 
     * @type {PutMetricRequestSqlBuilder}
     * @memberof PutMetricRequest
     */
    'sqlBuilder'?: PutMetricRequestSqlBuilder;
    /**
     * 
     * @type {PutMetricRequestMixpanel}
     * @memberof PutMetricRequest
     */
    'mixpanel'?: PutMetricRequestMixpanel;
}

export const PutMetricRequestTypeEnum = {
    Binomial: 'binomial',
    Count: 'count',
    Duration: 'duration',
    Revenue: 'revenue'
} as const;

export type PutMetricRequestTypeEnum = typeof PutMetricRequestTypeEnum[keyof typeof PutMetricRequestTypeEnum];

/**
 * 
 * @export
 * @interface PutMetricRequestBehavior
 */
export interface PutMetricRequestBehavior {
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestBehavior
     */
    'goal'?: PutMetricRequestBehaviorGoalEnum;
    /**
     * Used in conjunction with `capValue` to set the capping (winsorization). Set to null to turn capping off. \"absolute\" will cap user values at the `capValue` if it is greater than 0. \"percentile\" will cap user values at the percentile of user values in an experiment using the `capValue` for the percentile, if greater than 0. <br/> If `behavior.capping` is non-null, you must specify `behavior.capValue`.
     * @type {string}
     * @memberof PutMetricRequestBehavior
     */
    'capping'?: PutMetricRequestBehaviorCappingEnum;
    /**
     * This should be non-negative. <br/> Must specify `behavior.capping` when setting `behavior.capValue`.
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'capValue'?: number;
    /**
     * The start of a Conversion Window relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics#conversion-delay). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'conversionWindowStart'?: number;
    /**
     * The end of a [Conversion Window](/app/metrics#conversion-window) relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics#conversion-delay) + Conversion Window Hours settings in the UI. In other words, if you want a 48 hour window starting after 24 hours, you would set conversionWindowStart to 24 and conversionWindowEnd to 72 (24+48). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'conversionWindowEnd'?: number;
    /**
     * Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'riskThresholdSuccess'?: number;
    /**
     * Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'riskThresholdDanger'?: number;
    /**
     * Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'minPercentChange'?: number;
    /**
     * Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'maxPercentChange'?: number;
    /**
     * 
     * @type {number}
     * @memberof PutMetricRequestBehavior
     */
    'minSampleSize'?: number;
}

export const PutMetricRequestBehaviorGoalEnum = {
    Increase: 'increase',
    Decrease: 'decrease'
} as const;

export type PutMetricRequestBehaviorGoalEnum = typeof PutMetricRequestBehaviorGoalEnum[keyof typeof PutMetricRequestBehaviorGoalEnum];
export const PutMetricRequestBehaviorCappingEnum = {
    Absolute: 'absolute',
    Percentile: 'percentile'
} as const;

export type PutMetricRequestBehaviorCappingEnum = typeof PutMetricRequestBehaviorCappingEnum[keyof typeof PutMetricRequestBehaviorCappingEnum];

/**
 * Only use for MixPanel (non-SQL) Data Sources. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed.
 * @export
 * @interface PutMetricRequestMixpanel
 */
export interface PutMetricRequestMixpanel {
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestMixpanel
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestMixpanel
     */
    'eventValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestMixpanel
     */
    'userAggregation'?: string;
    /**
     * 
     * @type {Array<PostMetricRequestMixpanelConditionsInner>}
     * @memberof PutMetricRequestMixpanel
     */
    'conditions'?: Array<PostMetricRequestMixpanelConditionsInner>;
}
/**
 * Preferred way to define SQL. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed.
 * @export
 * @interface PutMetricRequestSql
 */
export interface PutMetricRequestSql {
    /**
     * 
     * @type {Array<string>}
     * @memberof PutMetricRequestSql
     */
    'identifierTypes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestSql
     */
    'conversionSQL'?: string;
    /**
     * Custom user level aggregation for your metric (default: `SUM(value)`)
     * @type {string}
     * @memberof PutMetricRequestSql
     */
    'userAggregationSQL'?: string;
    /**
     * The metric ID for a [denominator metric for funnel and ratio metrics](/app/metrics#denominator-ratio--funnel-metrics)
     * @type {string}
     * @memberof PutMetricRequestSql
     */
    'denominatorMetricId'?: string;
}
/**
 * An alternative way to specify a SQL metric, rather than a full query. Using `sql` is preferred to `sqlBuilder`. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed
 * @export
 * @interface PutMetricRequestSqlBuilder
 */
export interface PutMetricRequestSqlBuilder {
    /**
     * 
     * @type {Array<PostMetricRequestSqlBuilderIdentifierTypeColumnsInner>}
     * @memberof PutMetricRequestSqlBuilder
     */
    'identifierTypeColumns'?: Array<PostMetricRequestSqlBuilderIdentifierTypeColumnsInner>;
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestSqlBuilder
     */
    'tableName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestSqlBuilder
     */
    'valueColumnName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutMetricRequestSqlBuilder
     */
    'timestampColumnName'?: string;
    /**
     * 
     * @type {Array<PostMetricRequestSqlBuilderConditionsInner>}
     * @memberof PutMetricRequestSqlBuilder
     */
    'conditions'?: Array<PostMetricRequestSqlBuilderConditionsInner>;
}
/**
 * 
 * @export
 * @interface PutVisualChangeset200Response
 */
export interface PutVisualChangeset200Response {
    /**
     * 
     * @type {number}
     * @memberof PutVisualChangeset200Response
     */
    'nModified': number;
    /**
     * 
     * @type {VisualChangeset}
     * @memberof PutVisualChangeset200Response
     */
    'visualChangeset': VisualChangeset;
}
/**
 * 
 * @export
 * @interface SavedGroup
 */
export interface SavedGroup {
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'owner'?: any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'attributeKey': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'values': any;
}
/**
 * 
 * @export
 * @interface SdkConnection
 */
export interface SdkConnection {
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'languages': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'environment': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'project': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'encryptPayload': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'encryptionKey': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'includeVisualExperiments'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'includeDraftExperiments'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'includeExperimentNames'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'key': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'proxyEnabled': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'proxyHost': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'proxySigningKey': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'sseEnabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'hashSecureAttributes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'remoteEvalEnabled'?: any;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'dateUpdated': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'datasourceId': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'identifierType': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface ToggleFeatureRequest
 */
export interface ToggleFeatureRequest {
    /**
     * 
     * @type {string}
     * @memberof ToggleFeatureRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof ToggleFeatureRequest
     */
    'environments': { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface UpdateExperimentRequest
 */
export interface UpdateExperimentRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'assignmentQueryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'trackingKey'?: string;
    /**
     * Name of the experiment
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'name'?: string;
    /**
     * Project ID which the experiment belongs to
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'project'?: string;
    /**
     * Hypothesis of the experiment
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'hypothesis'?: string;
    /**
     * Description of the experiment
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateExperimentRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof UpdateExperimentRequest
     */
    'metrics'?: any;
    /**
     * 
     * @type {any}
     * @memberof UpdateExperimentRequest
     */
    'guardrailMetrics'?: any;
    /**
     * Email of the person who owns this experiment
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'owner'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateExperimentRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'status'?: UpdateExperimentRequestStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateExperimentRequest
     */
    'autoRefresh'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'hashAttribute'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateExperimentRequest
     */
    'hashVersion'?: UpdateExperimentRequestHashVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateExperimentRequest
     */
    'releasedVariationId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateExperimentRequest
     */
    'excludeFromPayload'?: boolean;
    /**
     * 
     * @type {Array<PostExperimentRequestVariationsInner>}
     * @memberof UpdateExperimentRequest
     */
    'variations'?: Array<PostExperimentRequestVariationsInner>;
    /**
     * 
     * @type {Array<PostExperimentRequestPhasesInner>}
     * @memberof UpdateExperimentRequest
     */
    'phases'?: Array<PostExperimentRequestPhasesInner>;
}

export const UpdateExperimentRequestStatusEnum = {
    Draft: 'draft',
    Running: 'running',
    Stopped: 'stopped'
} as const;

export type UpdateExperimentRequestStatusEnum = typeof UpdateExperimentRequestStatusEnum[keyof typeof UpdateExperimentRequestStatusEnum];
export const UpdateExperimentRequestHashVersionEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type UpdateExperimentRequestHashVersionEnum = typeof UpdateExperimentRequestHashVersionEnum[keyof typeof UpdateExperimentRequestHashVersionEnum];

/**
 * 
 * @export
 * @interface UpdateFeatureRequest
 */
export interface UpdateFeatureRequest {
    /**
     * Description of the feature
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFeatureRequest
     */
    'archived'?: boolean;
    /**
     * An associated project ID
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFeatureRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: PostFeatureRequestEnvironmentsValue; }}
     * @memberof UpdateFeatureRequest
     */
    'environments'?: { [key: string]: PostFeatureRequestEnvironmentsValue; };
    /**
     * Use JSON schema to validate the payload of a JSON-type feature value (enterprise only).
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'jsonSchema'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSavedGroupRequest
 */
export interface UpdateSavedGroupRequest {
    /**
     * The display name of the Saved Group
     * @type {string}
     * @memberof UpdateSavedGroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSavedGroupRequest
     */
    'values'?: Array<string>;
    /**
     * The person or team that owns this Saved Group. If no owner, you can pass an empty string.
     * @type {string}
     * @memberof UpdateSavedGroupRequest
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface VisualChange
 */
export interface VisualChange {
    /**
     * 
     * @type {string}
     * @memberof VisualChange
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisualChange
     */
    'css'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisualChange
     */
    'js'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisualChange
     */
    'variation': string;
    /**
     * 
     * @type {any}
     * @memberof VisualChange
     */
    'domMutations'?: any;
}
/**
 * 
 * @export
 * @interface VisualChangeset
 */
export interface VisualChangeset {
    /**
     * 
     * @type {string}
     * @memberof VisualChangeset
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'urlPatterns': any;
    /**
     * 
     * @type {string}
     * @memberof VisualChangeset
     */
    'editorUrl': string;
    /**
     * 
     * @type {string}
     * @memberof VisualChangeset
     */
    'experiment': string;
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'visualChanges': any;
}

/**
 * DataSourcesApi - axios parameter creator
 * @export
 */
export const DataSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single data source
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSource: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDataSource', 'id', id)
            const localVarPath = `/data-sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all data sources
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources: async (limit?: any, offset?: any, projectId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSourcesApi - functional programming interface
 * @export
 */
export const DataSourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single data source
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSource(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSource(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all data sources
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataSources(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDataSources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDataSources(limit, offset, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataSourcesApi - factory interface
 * @export
 */
export const DataSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataSourcesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single data source
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSource(id: any, options?: any): AxiosPromise<GetDataSource200Response> {
            return localVarFp.getDataSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all data sources
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources(limit?: any, offset?: any, projectId?: any, options?: any): AxiosPromise<ListDataSources200Response> {
            return localVarFp.listDataSources(limit, offset, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourcesApi - object-oriented interface
 * @export
 * @class DataSourcesApi
 * @extends {BaseAPI}
 */
export class DataSourcesApi extends BaseAPI {
    /**
     * 
     * @summary Get a single data source
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public getDataSource(id: any, options?: AxiosRequestConfig) {
        return DataSourcesApiFp(this.configuration).getDataSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all data sources
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public listDataSources(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig) {
        return DataSourcesApiFp(this.configuration).listDataSources(limit, offset, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DimensionsApi - axios parameter creator
 * @export
 */
export const DimensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single dimension
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDimension: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDimension', 'id', id)
            const localVarPath = `/dimensions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all dimensions
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDimensions: async (limit?: any, offset?: any, datasourceId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dimensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DimensionsApi - functional programming interface
 * @export
 */
export const DimensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DimensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single dimension
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDimension(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDimension200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDimension(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all dimensions
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDimensions(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDimensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDimensions(limit, offset, datasourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DimensionsApi - factory interface
 * @export
 */
export const DimensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DimensionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single dimension
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDimension(id: any, options?: any): AxiosPromise<GetDimension200Response> {
            return localVarFp.getDimension(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all dimensions
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDimensions(limit?: any, offset?: any, datasourceId?: any, options?: any): AxiosPromise<ListDimensions200Response> {
            return localVarFp.listDimensions(limit, offset, datasourceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DimensionsApi - object-oriented interface
 * @export
 * @class DimensionsApi
 * @extends {BaseAPI}
 */
export class DimensionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single dimension
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DimensionsApi
     */
    public getDimension(id: any, options?: AxiosRequestConfig) {
        return DimensionsApiFp(this.configuration).getDimension(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all dimensions
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [datasourceId] Filter by Data Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DimensionsApi
     */
    public listDimensions(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig) {
        return DimensionsApiFp(this.configuration).listDimensions(limit, offset, datasourceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperimentsApi - axios parameter creator
 * @export
 */
export const ExperimentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single experiment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExperiment', 'id', id)
            const localVarPath = `/experiments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get results for an experiment
         * @param {any} id The id of the requested resource
         * @param {string} [phase] 
         * @param {string} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults: async (id: any, phase?: string, dimension?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExperimentResults', 'id', id)
            const localVarPath = `/experiments/{id}/results`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (phase !== undefined) {
                localVarQueryParameter['phase'] = phase;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all experiments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {string} [experimentId] Filter the returned list by the experiment tracking key (id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments: async (limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experiments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }

            if (experimentId !== undefined) {
                localVarQueryParameter['experimentId'] = experimentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single experiment
         * @param {PostExperimentRequest} postExperimentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExperiment: async (postExperimentRequest: PostExperimentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postExperimentRequest' is not null or undefined
            assertParamExists('postExperiment', 'postExperimentRequest', postExperimentRequest)
            const localVarPath = `/experiments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postExperimentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single experiment
         * @param {any} id The id of the requested resource
         * @param {UpdateExperimentRequest} updateExperimentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment: async (id: any, updateExperimentRequest: UpdateExperimentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExperiment', 'id', id)
            // verify required parameter 'updateExperimentRequest' is not null or undefined
            assertParamExists('updateExperiment', 'updateExperimentRequest', updateExperimentRequest)
            const localVarPath = `/experiments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExperimentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsApi - functional programming interface
 * @export
 */
export const ExperimentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperimentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single experiment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperiment(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostExperiment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperiment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get results for an experiment
         * @param {any} id The id of the requested resource
         * @param {string} [phase] 
         * @param {string} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentResults(id: any, phase?: string, dimension?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExperimentResults200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentResults(id, phase, dimension, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all experiments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {string} [experimentId] Filter the returned list by the experiment tracking key (id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiments(limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperiments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiments(limit, offset, projectId, datasourceId, experimentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single experiment
         * @param {PostExperimentRequest} postExperimentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExperiment(postExperimentRequest: PostExperimentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostExperiment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postExperiment(postExperimentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a single experiment
         * @param {any} id The id of the requested resource
         * @param {UpdateExperimentRequest} updateExperimentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExperiment(id: any, updateExperimentRequest: UpdateExperimentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostExperiment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExperiment(id, updateExperimentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperimentsApi - factory interface
 * @export
 */
export const ExperimentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperimentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single experiment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(id: any, options?: any): AxiosPromise<PostExperiment200Response> {
            return localVarFp.getExperiment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get results for an experiment
         * @param {any} id The id of the requested resource
         * @param {string} [phase] 
         * @param {string} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults(id: any, phase?: string, dimension?: string, options?: any): AxiosPromise<GetExperimentResults200Response> {
            return localVarFp.getExperimentResults(id, phase, dimension, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all experiments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {string} [experimentId] Filter the returned list by the experiment tracking key (id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: string, options?: any): AxiosPromise<ListExperiments200Response> {
            return localVarFp.listExperiments(limit, offset, projectId, datasourceId, experimentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single experiment
         * @param {PostExperimentRequest} postExperimentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExperiment(postExperimentRequest: PostExperimentRequest, options?: any): AxiosPromise<PostExperiment200Response> {
            return localVarFp.postExperiment(postExperimentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a single experiment
         * @param {any} id The id of the requested resource
         * @param {UpdateExperimentRequest} updateExperimentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(id: any, updateExperimentRequest: UpdateExperimentRequest, options?: any): AxiosPromise<PostExperiment200Response> {
            return localVarFp.updateExperiment(id, updateExperimentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperimentsApi - object-oriented interface
 * @export
 * @class ExperimentsApi
 * @extends {BaseAPI}
 */
export class ExperimentsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single experiment
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperiment(id: any, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).getExperiment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get results for an experiment
     * @param {any} id The id of the requested resource
     * @param {string} [phase] 
     * @param {string} [dimension] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperimentResults(id: any, phase?: string, dimension?: string, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).getExperimentResults(id, phase, dimension, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all experiments
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {any} [datasourceId] Filter by Data Source
     * @param {string} [experimentId] Filter the returned list by the experiment tracking key (id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public listExperiments(limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: string, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).listExperiments(limit, offset, projectId, datasourceId, experimentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single experiment
     * @param {PostExperimentRequest} postExperimentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public postExperiment(postExperimentRequest: PostExperimentRequest, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).postExperiment(postExperimentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a single experiment
     * @param {any} id The id of the requested resource
     * @param {UpdateExperimentRequest} updateExperimentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public updateExperiment(id: any, updateExperimentRequest: UpdateExperimentRequest, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).updateExperiment(id, updateExperimentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeaturesApi - axios parameter creator
 * @export
 */
export const FeaturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single feature
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFeature', 'id', id)
            const localVarPath = `/features/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all features
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatures: async (limit?: any, offset?: any, projectId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single feature
         * @param {PostFeatureRequest} postFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeature: async (postFeatureRequest: PostFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postFeatureRequest' is not null or undefined
            assertParamExists('postFeature', 'postFeatureRequest', postFeatureRequest)
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle a feature in one or more environments
         * @param {any} id The id of the requested resource
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature: async (id: any, toggleFeatureRequest: ToggleFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('toggleFeature', 'id', id)
            // verify required parameter 'toggleFeatureRequest' is not null or undefined
            assertParamExists('toggleFeature', 'toggleFeatureRequest', toggleFeatureRequest)
            const localVarPath = `/features/{id}/toggle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toggleFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partially update a feature
         * @param {any} id The id of the requested resource
         * @param {UpdateFeatureRequest} updateFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature: async (id: any, updateFeatureRequest: UpdateFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFeature', 'id', id)
            // verify required parameter 'updateFeatureRequest' is not null or undefined
            assertParamExists('updateFeature', 'updateFeatureRequest', updateFeatureRequest)
            const localVarPath = `/features/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeaturesApi - functional programming interface
 * @export
 */
export const FeaturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeaturesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single feature
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeature(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFeature200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeature(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all features
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatures(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFeatures200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatures(limit, offset, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single feature
         * @param {PostFeatureRequest} postFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeature(postFeatureRequest: PostFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFeature200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFeature(postFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Toggle a feature in one or more environments
         * @param {any} id The id of the requested resource
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleFeature(id: any, toggleFeatureRequest: ToggleFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFeature200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleFeature(id, toggleFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Partially update a feature
         * @param {any} id The id of the requested resource
         * @param {UpdateFeatureRequest} updateFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeature(id: any, updateFeatureRequest: UpdateFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFeature200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeature(id, updateFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeaturesApi - factory interface
 * @export
 */
export const FeaturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeaturesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single feature
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature(id: any, options?: any): AxiosPromise<PostFeature200Response> {
            return localVarFp.getFeature(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all features
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatures(limit?: any, offset?: any, projectId?: any, options?: any): AxiosPromise<ListFeatures200Response> {
            return localVarFp.listFeatures(limit, offset, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single feature
         * @param {PostFeatureRequest} postFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeature(postFeatureRequest: PostFeatureRequest, options?: any): AxiosPromise<PostFeature200Response> {
            return localVarFp.postFeature(postFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle a feature in one or more environments
         * @param {any} id The id of the requested resource
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature(id: any, toggleFeatureRequest: ToggleFeatureRequest, options?: any): AxiosPromise<PostFeature200Response> {
            return localVarFp.toggleFeature(id, toggleFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partially update a feature
         * @param {any} id The id of the requested resource
         * @param {UpdateFeatureRequest} updateFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature(id: any, updateFeatureRequest: UpdateFeatureRequest, options?: any): AxiosPromise<PostFeature200Response> {
            return localVarFp.updateFeature(id, updateFeatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeaturesApi - object-oriented interface
 * @export
 * @class FeaturesApi
 * @extends {BaseAPI}
 */
export class FeaturesApi extends BaseAPI {
    /**
     * 
     * @summary Get a single feature
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public getFeature(id: any, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).getFeature(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all features
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public listFeatures(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).listFeatures(limit, offset, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single feature
     * @param {PostFeatureRequest} postFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public postFeature(postFeatureRequest: PostFeatureRequest, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).postFeature(postFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle a feature in one or more environments
     * @param {any} id The id of the requested resource
     * @param {ToggleFeatureRequest} toggleFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public toggleFeature(id: any, toggleFeatureRequest: ToggleFeatureRequest, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).toggleFeature(id, toggleFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partially update a feature
     * @param {any} id The id of the requested resource
     * @param {UpdateFeatureRequest} updateFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public updateFeature(id: any, updateFeatureRequest: UpdateFeatureRequest, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).updateFeature(id, updateFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMetric', 'id', id)
            const localVarPath = `/metrics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMetric', 'id', id)
            const localVarPath = `/metrics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all metrics
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics: async (limit?: any, offset?: any, projectId?: any, datasourceId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single metric
         * @param {PostMetricRequest} postMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric: async (postMetricRequest: PostMetricRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postMetricRequest' is not null or undefined
            assertParamExists('postMetric', 'postMetricRequest', postMetricRequest)
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postMetricRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a metric
         * @param {any} id The id of the requested resource
         * @param {PutMetricRequest} putMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetric: async (id: any, putMetricRequest: PutMetricRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putMetric', 'id', id)
            // verify required parameter 'putMetricRequest' is not null or undefined
            assertParamExists('putMetric', 'putMetricRequest', putMetricRequest)
            const localVarPath = `/metrics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putMetricRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all metrics
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetrics(limit?: any, offset?: any, projectId?: any, datasourceId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetrics(limit, offset, projectId, datasourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single metric
         * @param {PostMetricRequest} postMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMetric(postMetricRequest: PostMetricRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetric(postMetricRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a metric
         * @param {any} id The id of the requested resource
         * @param {PutMetricRequest} putMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMetric(id: any, putMetricRequest: PutMetricRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMetric(id, putMetricRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric(id: any, options?: any): AxiosPromise<DeleteMetric200Response> {
            return localVarFp.deleteMetric(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(id: any, options?: any): AxiosPromise<PostMetric200Response> {
            return localVarFp.getMetric(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all metrics
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics(limit?: any, offset?: any, projectId?: any, datasourceId?: any, options?: any): AxiosPromise<ListMetrics200Response> {
            return localVarFp.listMetrics(limit, offset, projectId, datasourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single metric
         * @param {PostMetricRequest} postMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric(postMetricRequest: PostMetricRequest, options?: any): AxiosPromise<PostMetric200Response> {
            return localVarFp.postMetric(postMetricRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a metric
         * @param {any} id The id of the requested resource
         * @param {PutMetricRequest} putMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetric(id: any, putMetricRequest: PutMetricRequest, options?: any): AxiosPromise<PutMetric200Response> {
            return localVarFp.putMetric(id, putMetricRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a metric
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public deleteMetric(id: any, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).deleteMetric(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single metric
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetric(id: any, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetric(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all metrics
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {any} [datasourceId] Filter by Data Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetrics(limit?: any, offset?: any, projectId?: any, datasourceId?: any, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetrics(limit, offset, projectId, datasourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single metric
     * @param {PostMetricRequest} postMetricRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public postMetric(postMetricRequest: PostMetricRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).postMetric(postMetricRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a metric
     * @param {any} id The id of the requested resource
     * @param {PutMetricRequest} putMetricRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public putMetric(id: any, putMetricRequest: PutMetricRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).putMetric(id, putMetricRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all organizations
         * @param {string} [search] Search string to search organization names and owner emails by
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (search?: string, limit?: any, offset?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single organization
         * @param {PostOrganizationRequest} postOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganization: async (postOrganizationRequest: PostOrganizationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postOrganizationRequest' is not null or undefined
            assertParamExists('postOrganization', 'postOrganizationRequest', postOrganizationRequest)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all organizations
         * @param {string} [search] Search string to search organization names and owner emails by
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(search?: string, limit?: any, offset?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(search, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single organization
         * @param {PostOrganizationRequest} postOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrganization(postOrganizationRequest: PostOrganizationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostOrganization200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrganization(postOrganizationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all organizations
         * @param {string} [search] Search string to search organization names and owner emails by
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(search?: string, limit?: any, offset?: any, options?: any): AxiosPromise<ListOrganizations200Response> {
            return localVarFp.listOrganizations(search, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single organization
         * @param {PostOrganizationRequest} postOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganization(postOrganizationRequest: PostOrganizationRequest, options?: any): AxiosPromise<PostOrganization200Response> {
            return localVarFp.postOrganization(postOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Get all organizations
     * @param {string} [search] Search string to search organization names and owner emails by
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizations(search?: string, limit?: any, offset?: any, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizations(search, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single organization
     * @param {PostOrganizationRequest} postOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public postOrganization(postOrganizationRequest: PostOrganizationRequest, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).postOrganization(postOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single project
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (limit?: any, offset?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single project
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProject200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all projects
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(limit?: any, offset?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single project
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: any, options?: any): AxiosPromise<GetProject200Response> {
            return localVarFp.getProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(limit?: any, offset?: any, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.listProjects(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single project
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(id: any, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(limit?: any, offset?: any, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SavedGroupsApi - axios parameter creator
 * @export
 */
export const SavedGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedGroup: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedGroup', 'id', id)
            const localVarPath = `/saved-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedGroup: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSavedGroup', 'id', id)
            const localVarPath = `/saved-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all saved group
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedGroups: async (limit?: any, offset?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single saved group
         * @param {PostSavedGroupRequest} postSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedGroup: async (postSavedGroupRequest: PostSavedGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSavedGroupRequest' is not null or undefined
            assertParamExists('postSavedGroup', 'postSavedGroupRequest', postSavedGroupRequest)
            const localVarPath = `/saved-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSavedGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partially update a single saved group
         * @param {any} id The id of the requested resource
         * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedGroup: async (id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSavedGroup', 'id', id)
            // verify required parameter 'updateSavedGroupRequest' is not null or undefined
            assertParamExists('updateSavedGroup', 'updateSavedGroupRequest', updateSavedGroupRequest)
            const localVarPath = `/saved-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSavedGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedGroupsApi - functional programming interface
 * @export
 */
export const SavedGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedGroup(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedGroup(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all saved group
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedGroups(limit?: any, offset?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSavedGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedGroups(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single saved group
         * @param {PostSavedGroupRequest} postSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSavedGroup(postSavedGroupRequest: PostSavedGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSavedGroup(postSavedGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Partially update a single saved group
         * @param {any} id The id of the requested resource
         * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSavedGroup(id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSavedGroup(id, updateSavedGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SavedGroupsApi - factory interface
 * @export
 */
export const SavedGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedGroup(id: any, options?: any): AxiosPromise<DeleteMetric200Response> {
            return localVarFp.deleteSavedGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedGroup(id: any, options?: any): AxiosPromise<PostSavedGroup200Response> {
            return localVarFp.getSavedGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all saved group
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedGroups(limit?: any, offset?: any, options?: any): AxiosPromise<ListSavedGroups200Response> {
            return localVarFp.listSavedGroups(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single saved group
         * @param {PostSavedGroupRequest} postSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedGroup(postSavedGroupRequest: PostSavedGroupRequest, options?: any): AxiosPromise<PostSavedGroup200Response> {
            return localVarFp.postSavedGroup(postSavedGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partially update a single saved group
         * @param {any} id The id of the requested resource
         * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedGroup(id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options?: any): AxiosPromise<PostSavedGroup200Response> {
            return localVarFp.updateSavedGroup(id, updateSavedGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SavedGroupsApi - object-oriented interface
 * @export
 * @class SavedGroupsApi
 * @extends {BaseAPI}
 */
export class SavedGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a single saved group
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public deleteSavedGroup(id: any, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).deleteSavedGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single saved group
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public getSavedGroup(id: any, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).getSavedGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all saved group
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public listSavedGroups(limit?: any, offset?: any, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).listSavedGroups(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single saved group
     * @param {PostSavedGroupRequest} postSavedGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public postSavedGroup(postSavedGroupRequest: PostSavedGroupRequest, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).postSavedGroup(postSavedGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partially update a single saved group
     * @param {any} id The id of the requested resource
     * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public updateSavedGroup(id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).updateSavedGroup(id, updateSavedGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SdkConnectionsApi - axios parameter creator
 * @export
 */
export const SdkConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single sdk connection
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdkConnection: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSdkConnection', 'id', id)
            const localVarPath = `/sdk-connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sdk connections
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {string} [withProxy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdkConnections: async (limit?: any, offset?: any, projectId?: any, withProxy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdk-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (withProxy !== undefined) {
                localVarQueryParameter['withProxy'] = withProxy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SdkConnectionsApi - functional programming interface
 * @export
 */
export const SdkConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SdkConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single sdk connection
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdkConnection(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSdkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdkConnection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all sdk connections
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {string} [withProxy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSdkConnections(limit?: any, offset?: any, projectId?: any, withProxy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSdkConnections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSdkConnections(limit, offset, projectId, withProxy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SdkConnectionsApi - factory interface
 * @export
 */
export const SdkConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SdkConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single sdk connection
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdkConnection(id: any, options?: any): AxiosPromise<GetSdkConnection200Response> {
            return localVarFp.getSdkConnection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sdk connections
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {string} [withProxy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdkConnections(limit?: any, offset?: any, projectId?: any, withProxy?: string, options?: any): AxiosPromise<ListSdkConnections200Response> {
            return localVarFp.listSdkConnections(limit, offset, projectId, withProxy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SdkConnectionsApi - object-oriented interface
 * @export
 * @class SdkConnectionsApi
 * @extends {BaseAPI}
 */
export class SdkConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single sdk connection
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdkConnectionsApi
     */
    public getSdkConnection(id: any, options?: AxiosRequestConfig) {
        return SdkConnectionsApiFp(this.configuration).getSdkConnection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sdk connections
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {string} [withProxy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdkConnectionsApi
     */
    public listSdkConnections(limit?: any, offset?: any, projectId?: any, withProxy?: string, options?: AxiosRequestConfig) {
        return SdkConnectionsApiFp(this.configuration).listSdkConnections(limit, offset, projectId, withProxy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single segment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all segments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: any, offset?: any, datasourceId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single segment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSegment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all segments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSegments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, datasourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single segment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(id: any, options?: any): AxiosPromise<GetSegment200Response> {
            return localVarFp.getSegment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all segments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegments(limit?: any, offset?: any, datasourceId?: any, options?: any): AxiosPromise<ListSegments200Response> {
            return localVarFp.listSegments(limit, offset, datasourceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single segment
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(id: any, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all segments
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [datasourceId] Filter by Data Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public listSegments(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).listSegments(limit, offset, datasourceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VisualChangesetsApi - axios parameter creator
 * @export
 */
export const VisualChangesetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single visual changeset
         * @param {any} id The id of the requested resource
         * @param {number} [includeExperiment] Include the associated experiment in payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVisualChangeset: async (id: any, includeExperiment?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVisualChangeset', 'id', id)
            const localVarPath = `/visual-changesets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeExperiment !== undefined) {
                localVarQueryParameter['includeExperiment'] = includeExperiment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all visual changesets
         * @param {string} id The experiment id the visual changesets belong to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVisualChangesets: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listVisualChangesets', 'id', id)
            const localVarPath = `/experiments/{id}/visual-changesets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVisualChange: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postVisualChange', 'id', id)
            const localVarPath = `/visual-changesets/{id}/visual-change`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} visualChangeId Specify a specific visual change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChange: async (id: any, visualChangeId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putVisualChange', 'id', id)
            // verify required parameter 'visualChangeId' is not null or undefined
            assertParamExists('putVisualChange', 'visualChangeId', visualChangeId)
            const localVarPath = `/visual-changesets/{id}/visual-change/{visualChangeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"visualChangeId"}}`, encodeURIComponent(String(visualChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChangeset: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putVisualChangeset', 'id', id)
            const localVarPath = `/visual-changesets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisualChangesetsApi - functional programming interface
 * @export
 */
export const VisualChangesetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisualChangesetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single visual changeset
         * @param {any} id The id of the requested resource
         * @param {number} [includeExperiment] Include the associated experiment in payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVisualChangeset(id: any, includeExperiment?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVisualChangeset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVisualChangeset(id, includeExperiment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all visual changesets
         * @param {string} id The experiment id the visual changesets belong to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVisualChangesets(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVisualChangesets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVisualChangesets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVisualChange(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostVisualChange200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postVisualChange(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} visualChangeId Specify a specific visual change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVisualChange(id: any, visualChangeId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostVisualChange200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putVisualChange(id, visualChangeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVisualChangeset(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutVisualChangeset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putVisualChangeset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VisualChangesetsApi - factory interface
 * @export
 */
export const VisualChangesetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisualChangesetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single visual changeset
         * @param {any} id The id of the requested resource
         * @param {number} [includeExperiment] Include the associated experiment in payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVisualChangeset(id: any, includeExperiment?: number, options?: any): AxiosPromise<GetVisualChangeset200Response> {
            return localVarFp.getVisualChangeset(id, includeExperiment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all visual changesets
         * @param {string} id The experiment id the visual changesets belong to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVisualChangesets(id: string, options?: any): AxiosPromise<ListVisualChangesets200Response> {
            return localVarFp.listVisualChangesets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVisualChange(id: any, options?: any): AxiosPromise<PostVisualChange200Response> {
            return localVarFp.postVisualChange(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} visualChangeId Specify a specific visual change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChange(id: any, visualChangeId: any, options?: any): AxiosPromise<PostVisualChange200Response> {
            return localVarFp.putVisualChange(id, visualChangeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChangeset(id: any, options?: any): AxiosPromise<PutVisualChangeset200Response> {
            return localVarFp.putVisualChangeset(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisualChangesetsApi - object-oriented interface
 * @export
 * @class VisualChangesetsApi
 * @extends {BaseAPI}
 */
export class VisualChangesetsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single visual changeset
     * @param {any} id The id of the requested resource
     * @param {number} [includeExperiment] Include the associated experiment in payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public getVisualChangeset(id: any, includeExperiment?: number, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).getVisualChangeset(id, includeExperiment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all visual changesets
     * @param {string} id The experiment id the visual changesets belong to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public listVisualChangesets(id: string, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).listVisualChangesets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a visual change for a visual changeset
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public postVisualChange(id: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).postVisualChange(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a visual change for a visual changeset
     * @param {any} id The id of the requested resource
     * @param {any} visualChangeId Specify a specific visual change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public putVisualChange(id: any, visualChangeId: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).putVisualChange(id, visualChangeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a visual changeset
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public putVisualChangeset(id: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).putVisualChangeset(id, options).then((request) => request(this.axios, this.basePath));
    }
}



